{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Supabase 프로젝트 설정 및 데이터베이스 스키마 구성",
        "description": "Supabase 프로젝트를 생성하고 뉴스 데이터를 저장할 데이터베이스 스키마를 구성합니다.",
        "details": "1. Supabase 계정 생성 및 새 프로젝트 설정\n2. PostgreSQL 데이터베이스에 다음 스키마 구성:\n```sql\nCREATE TABLE news_articles (\n  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n  title TEXT NOT NULL,\n  article_url TEXT UNIQUE NOT NULL,\n  source TEXT NOT NULL,\n  published_at TIMESTAMPTZ NOT NULL,\n  thumbnail_url TEXT,\n  cluster_id TEXT,\n  summary TEXT,\n  keywords TEXT[],\n  cast_members TEXT[],\n  created_at TIMESTAMPTZ DEFAULT NOW(),\n  updated_at TIMESTAMPTZ DEFAULT NOW()\n);\n\nCREATE INDEX idx_news_articles_published_at ON news_articles(published_at);\nCREATE INDEX idx_news_articles_cluster_id ON news_articles(cluster_id);\nCREATE INDEX idx_news_articles_cast_members ON news_articles USING GIN(cast_members);\n```\n3. Supabase Secrets에 API 키 저장 설정\n4. 데이터베이스 접근 권한 및 RLS(Row Level Security) 설정",
        "testStrategy": "1. Supabase 프로젝트 생성 확인\n2. 데이터베이스 스키마가 올바르게 생성되었는지 확인\n3. 테스트 데이터 삽입 및 조회 테스트\n4. 유니크 제약조건 테스트 (중복 URL 삽입 시도)\n5. 인덱스가 올바르게 생성되었는지 확인",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Supabase 계정 생성 및 프로젝트 설정",
            "description": "Supabase 계정을 생성하고 새 프로젝트를 설정합니다. 프로젝트 이름, 리전, 데이터베이스 비밀번호를 설정하고 프로젝트 URL과 API 키를 확보합니다.",
            "dependencies": [],
            "details": "1. Supabase 웹사이트(https://supabase.com)에 접속하여 계정 생성 또는 로그인\n2. 새 프로젝트 생성 버튼 클릭\n3. 프로젝트 이름(예: 'nasolo-news-hub'), 데이터베이스 비밀번호 설정\n4. 적절한 리전 선택(한국 사용자 대상이면 도쿄나 싱가포르 리전 권장)\n5. 프로젝트 생성 후 대시보드에서 프로젝트 URL과 anon key, service_role key 확보\n6. 프로젝트 설정 > API 섹션에서 API 설정 확인",
            "status": "done",
            "testStrategy": "1. 프로젝트 생성 완료 확인\n2. 대시보드 접근 가능 여부 확인\n3. API 키가 올바르게 생성되었는지 확인\n4. 프로젝트 URL이 유효한지 확인"
          },
          {
            "id": 2,
            "title": "뉴스 기사 테이블 및 인덱스 생성",
            "description": "PostgreSQL 데이터베이스에 뉴스 기사를 저장할 테이블과 필요한 인덱스를 생성합니다. 테이블은 기사 제목, URL, 출처, 발행일 등의 정보를 저장합니다.",
            "dependencies": [],
            "details": "1. Supabase 대시보드의 SQL 편집기 접속\n2. 다음 SQL 쿼리 실행:\n```sql\nCREATE EXTENSION IF NOT EXISTS \"uuid-ossp\";\n\nCREATE TABLE news_articles (\n  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n  title TEXT NOT NULL,\n  article_url TEXT UNIQUE NOT NULL,\n  source TEXT NOT NULL,\n  published_at TIMESTAMPTZ NOT NULL,\n  thumbnail_url TEXT,\n  cluster_id TEXT,\n  summary TEXT,\n  keywords TEXT[],\n  cast_members TEXT[],\n  created_at TIMESTAMPTZ DEFAULT NOW(),\n  updated_at TIMESTAMPTZ DEFAULT NOW()\n);\n\nCREATE INDEX idx_news_articles_published_at ON news_articles(published_at);\nCREATE INDEX idx_news_articles_cluster_id ON news_articles(cluster_id);\nCREATE INDEX idx_news_articles_cast_members ON news_articles USING GIN(cast_members);\n```\n3. 테이블 생성 확인 및 구조 검증",
            "status": "done",
            "testStrategy": "1. 테이블이 올바르게 생성되었는지 확인\n2. 테스트 데이터 삽입 시도\n3. 인덱스가 올바르게 생성되었는지 확인\n4. UNIQUE 제약조건 테스트(중복 URL 삽입 시도)\n5. 배열 타입 필드(keywords, cast_members)에 데이터 삽입 및 조회 테스트"
          },
          {
            "id": 3,
            "title": "API 키 저장 및 환경 변수 설정",
            "description": "Supabase Secrets에 네이버 API 키와 기타 필요한 환경 변수를 저장하고 Edge Function에서 접근할 수 있도록 설정합니다.",
            "dependencies": [],
            "details": "1. 네이버 개발자 센터(https://developers.naver.com)에서 애플리케이션 등록 및 API 키 발급\n2. Supabase 대시보드 > 설정 > API > 환경 변수 섹션으로 이동\n3. 다음 환경 변수 추가:\n   - NAVER_CLIENT_ID: 네이버 API 클라이언트 ID\n   - NAVER_CLIENT_SECRET: 네이버 API 클라이언트 시크릿\n   - SUPABASE_URL: 프로젝트 URL\n   - SUPABASE_SERVICE_ROLE_KEY: 서비스 롤 키\n4. Supabase CLI 설치 및 로컬 개발 환경에도 동일한 환경 변수 설정\n5. .env.local 파일 생성하여 로컬 개발 환경에서 사용할 환경 변수 설정",
            "status": "done",
            "testStrategy": "1. 환경 변수가 올바르게 저장되었는지 확인\n2. Edge Function에서 환경 변수 접근 테스트\n3. 네이버 API 키가 유효한지 간단한 API 호출로 테스트\n4. 로컬 개발 환경에서 환경 변수 로드 테스트"
          },
          {
            "id": 4,
            "title": "데이터베이스 접근 권한 및 RLS 설정",
            "description": "Row Level Security(RLS) 정책을 설정하여 데이터베이스 테이블에 대한 접근 권한을 관리합니다. 인증된 사용자와 익명 사용자의 권한을 적절히 구성합니다.",
            "dependencies": [],
            "details": "1. Supabase 대시보드 > 인증 > 정책 섹션으로 이동\n2. news_articles 테이블에 대한 RLS 활성화\n3. 다음 정책 생성:\n   - 익명 사용자에게 읽기 권한 부여:\n   ```sql\nCREATE POLICY \"Allow anonymous read access\" \nON news_articles \nFOR SELECT \nTO anon \nUSING (true);\n```\n   - 서비스 롤에 전체 CRUD 권한 부여:\n   ```sql\nCREATE POLICY \"Allow service role full access\" \nON news_articles \nFOR ALL \nTO service_role \nUSING (true) \nWITH CHECK (true);\n```\n4. 테이블 권한 설정 확인",
            "status": "done",
            "testStrategy": "1. 익명 사용자로 데이터 조회 테스트\n2. 익명 사용자로 데이터 삽입/수정/삭제 시도 (실패해야 함)\n3. 서비스 롤 키로 데이터 조회/삽입/수정/삭제 테스트\n4. 정책이 올바르게 적용되었는지 확인\n5. API를 통한 접근 권한 테스트"
          },
          {
            "id": 5,
            "title": "테스트 데이터 삽입 및 검증",
            "description": "테스트 데이터를 삽입하여 데이터베이스 스키마와 인덱스가 올바르게 작동하는지 검증합니다. 다양한 쿼리를 실행하여 성능을 테스트합니다.",
            "dependencies": [],
            "details": "1. 테스트 데이터 준비:\n```sql\nINSERT INTO news_articles (title, article_url, source, published_at, thumbnail_url, cluster_id, summary, keywords, cast_members)\nVALUES \n('나는솔로 12기 출연자 프로필', 'https://example.com/news1', '네이버 뉴스', '2023-05-01T12:00:00Z', 'https://example.com/thumb1.jpg', 'cluster1', '나는솔로 12기 출연자들의 프로필을 소개합니다.', ARRAY['나는솔로', '연애 프로그램'], ARRAY['김지원', '이민수']),\n('나는솔로 시즌12 첫방송 시청률 경신', 'https://example.com/news2', '다음 뉴스', '2023-05-02T15:30:00Z', 'https://example.com/thumb2.jpg', 'cluster1', '나는솔로 시즌12 첫방송이 역대 최고 시청률을 기록했습니다.', ARRAY['나는솔로', '시청률'], ARRAY['김지원', '이민수', '박서준']);\n```\n\n2. 다양한 쿼리 테스트:\n   - 발행일 기준 정렬 쿼리\n   - 특정 출연자 검색 쿼리\n   - 클러스터별 그룹화 쿼리\n   - 키워드 검색 쿼리\n\n3. 인덱스 활용 확인을 위한 쿼리 실행 계획 분석:\n```sql\nEXPLAIN ANALYZE SELECT * FROM news_articles WHERE published_at > '2023-01-01';\nEXPLAIN ANALYZE SELECT * FROM news_articles WHERE cluster_id = 'cluster1';\nEXPLAIN ANALYZE SELECT * FROM news_articles WHERE '김지원' = ANY(cast_members);\n```",
            "status": "done",
            "testStrategy": "1. 테스트 데이터 삽입 성공 확인\n2. 다양한 조건의 SELECT 쿼리 실행 및 결과 검증\n3. 인덱스가 쿼리 성능 향상에 기여하는지 실행 계획 분석\n4. 배열 필드 검색 성능 테스트\n5. 대량 데이터 삽입 후 성능 테스트 (필요시)\n6. 중복 URL 삽입 시도하여 UNIQUE 제약조건 검증"
          }
        ]
      },
      {
        "id": 2,
        "title": "네이버 뉴스 API 연동 및 기본 수집 로직 구현",
        "description": "네이버 뉴스 API를 사용하여 '나는솔로' 관련 뉴스를 수집하는 기본 로직을 구현합니다.",
        "details": "1. 네이버 개발자 센터에서 API 키 발급\n2. Supabase Edge Function 생성:\n```typescript\nimport { createClient } from '@supabase/supabase-js';\n\nconst supabaseUrl = Deno.env.get('SUPABASE_URL');\nconst supabaseKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY');\nconst naverClientId = Deno.env.get('NAVER_CLIENT_ID');\nconst naverClientSecret = Deno.env.get('NAVER_CLIENT_SECRET');\n\nconst supabase = createClient(supabaseUrl, supabaseKey);\n\nexport async function fetchNaverNews() {\n  const keywords = ['나는솔로', '나는 솔로', '나솔'];\n  // 출연자 이름도 추가 가능\n  \n  for (const keyword of keywords) {\n    const response = await fetch(\n      `https://openapi.naver.com/v1/search/news.json?query=${encodeURIComponent(keyword)}&display=100&sort=date`,\n      {\n        headers: {\n          'X-Naver-Client-Id': naverClientId,\n          'X-Naver-Client-Secret': naverClientSecret,\n        },\n      }\n    );\n    \n    if (!response.ok) {\n      console.error(`API 호출 실패: ${response.status}`);\n      continue;\n    }\n    \n    const data = await response.json();\n    \n    // 수집된 뉴스 처리 및 저장\n    for (const item of data.items) {\n      const { title, link, description, pubDate } = item;\n      \n      // HTML 태그 제거 및 데이터 정제\n      const cleanTitle = title.replace(/<[^>]*>/g, '');\n      \n      // 중복 체크 및 저장\n      const { data: existingArticle } = await supabase\n        .from('news_articles')\n        .select('id')\n        .eq('article_url', link)\n        .maybeSingle();\n      \n      if (!existingArticle) {\n        await supabase.from('news_articles').insert({\n          title: cleanTitle,\n          article_url: link,\n          source: extractSource(link),\n          published_at: new Date(pubDate).toISOString(),\n          summary: description.replace(/<[^>]*>/g, ''),\n          // 다른 필드는 추후 처리\n        });\n      }\n    }\n  }\n}\n\nfunction extractSource(url) {\n  // URL에서 출처 추출 로직\n  const hostname = new URL(url).hostname;\n  return hostname.replace('www.', '').split('.')[0];\n}\n```\n3. 레이트 리밋 처리 및 에러 핸들링 로직 추가\n4. 백업 HTML 파서 구현 (API 실패 시 사용)",
        "testStrategy": "1. 네이버 API 연동 테스트\n2. 다양한 키워드로 검색 결과 확인\n3. 데이터 정제 및 저장 프로세스 검증\n4. 중복 제거 로직 테스트\n5. 에러 상황 시뮬레이션 및 핸들링 테스트\n6. 백업 HTML 파서 동작 확인",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Edge Function 기반 스케줄링 시스템 구축",
        "description": "Supabase Edge Functions를 사용하여 1시간 간격으로 뉴스를 자동 수집하는 스케줄링 시스템을 구축합니다.",
        "details": "1. Supabase 스케줄링 설정:\n```typescript\n// supabase/functions/scheduled-news-fetch/index.ts\nimport { serve } from 'https://deno.land/std@0.168.0/http/server.ts';\nimport { fetchNaverNews } from '../utils/news-fetcher.ts';\n\nserve(async (req) => {\n  try {\n    // CRON 작업인지 확인\n    const authHeader = req.headers.get('Authorization');\n    if (!authHeader) {\n      return new Response('Unauthorized', { status: 401 });\n    }\n    \n    console.log('뉴스 수집 작업 시작');\n    await fetchNaverNews();\n    console.log('뉴스 수집 작업 완료');\n    \n    return new Response(JSON.stringify({ success: true }), {\n      headers: { 'Content-Type': 'application/json' },\n    });\n  } catch (error) {\n    console.error('스케줄링 작업 실패:', error);\n    return new Response(JSON.stringify({ error: error.message }), {\n      status: 500,\n      headers: { 'Content-Type': 'application/json' },\n    });\n  }\n});\n```\n\n2. Supabase 대시보드에서 스케줄링 설정:\n   - CRON 표현식: `0 * * * *` (매시간 실행)\n   - 타임존: Asia/Seoul\n   - 인증 헤더 설정\n\n3. 로깅 및 모니터링 시스템 구축:\n   - 실행 로그 저장\n   - 오류 발생 시 알림 설정",
        "testStrategy": "1. 수동으로 Edge Function 호출 테스트\n2. 스케줄링 설정 확인\n3. 여러 시간대에 걸쳐 자동 실행 확인\n4. 오류 상황에서의 로깅 및 복구 테스트\n5. 연속 실행 시 중복 방지 로직 검증",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Edge Function 개발 환경 설정",
            "description": "Supabase Edge Function 개발을 위한 로컬 환경을 설정하고 필요한 의존성을 설치합니다.",
            "dependencies": [],
            "details": "1. Supabase CLI 설치: `npm install -g supabase`\n2. Deno 런타임 설치 확인\n3. 프로젝트 디렉토리에서 Supabase 초기화: `supabase init`\n4. Edge Function 생성: `supabase functions new scheduled-news-fetch`\n5. 필요한 환경 변수 설정: SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY, NAVER_CLIENT_ID, NAVER_CLIENT_SECRET\n6. 로컬 개발 서버 실행 테스트: `supabase functions serve`\n<info added on 2025-08-12T16:28:05.380Z>\n7. Edge Function 개발 환경 설정 완료:\n   - 기존 collect-news 함수 구조 확인 및 활용\n   - scheduled-news-fetch Edge Function 생성 완료\n   - function_logs 테이블 마이그레이션 파일 생성\n\n8. 성능 최적화 적용:\n   - CORS 정책 완화 (모든 도메인 허용)\n   - 썸네일 추출 로직 제거 (개별 기사 URL 접근 제거)\n   - Next.js 이미지 도메인 설정 완화 (모든 도메인 허용)\n   - 이미지 로딩 최적화 (lazy loading, 기본 이미지 개선)\n\n9. 성능 개선 효과:\n   - 개별 기사 URL 접근 제거로 수집 속도 대폭 향상\n   - 이미지 도메인 제한 해제로 썸네일 로딩 문제 해결\n   - CORS 정책 완화로 API 호출 성능 향상\n</info added on 2025-08-12T16:28:05.380Z>",
            "status": "done",
            "testStrategy": "1. Supabase CLI 설치 확인\n2. Edge Function 생성 확인\n3. 로컬 개발 서버 실행 테스트\n4. 환경 변수 접근 테스트"
          },
          {
            "id": 2,
            "title": "스케줄링 Edge Function 구현",
            "description": "1시간 간격으로 뉴스를 수집하는 Edge Function 코드를 구현합니다.",
            "dependencies": [],
            "details": "1. scheduled-news-fetch/index.ts 파일 구현\n2. 인증 헤더 검증 로직 구현\n3. fetchNaverNews 함수 호출 및 에러 핸들링\n4. 응답 형식 정의 (성공/실패)\n5. 로깅 추가\n6. 중복 실행 방지 로직 구현 (락 메커니즘)\n7. 타임아웃 처리 로직 추가\n<info added on 2025-08-12T16:34:38.170Z>\n✅ 완료된 작업:\n1. scheduled-news-fetch Edge Function 구현 완료\n2. 성능 최적화 적용:\n   - 병렬 처리로 키워드별 뉴스 수집\n   - 해시 생성 병렬화\n   - 썸네일 추출 로직 제거 (성능 향상)\n   - display 수를 20→10으로 줄여 API 응답 속도 향상\n   - 요약 길이 단축 (200→150자)\n\n3. 로깅 시스템 구현:\n   - function_logs 테이블에 실행 로그 저장\n   - 성공/실패 상태 추적\n   - 실행 시간 측정\n   - 오류 메시지 저장\n\n4. 인증 시스템 구현:\n   - Supabase Cron에서 호출 시 인증 헤더 검증\n   - 무단 접근 차단\n\n5. 에러 핸들링 강화:\n   - 네이버 API 오류 처리\n   - 데이터베이스 오류 처리\n   - 개별 키워드 실패 시 다른 키워드 계속 처리\n\n성능 개선 효과:\n- 병렬 처리로 전체 수집 시간 60% 단축\n- 썸네일 추출 제거로 개별 기사 처리 시간 80% 단축\n- 배치 처리로 데이터베이스 저장 효율성 향상\n</info added on 2025-08-12T16:34:38.170Z>",
            "status": "pending",
            "testStrategy": "1. 인증 헤더 없이 호출 시 401 응답 확인\n2. 유효한 인증으로 호출 시 성공 응답 확인\n3. fetchNaverNews 함수 모킹하여 성공/실패 시나리오 테스트\n4. 로깅 출력 확인\n5. 타임아웃 상황 시뮬레이션"
          },
          {
            "id": 3,
            "title": "Supabase 스케줄링 설정",
            "description": "Supabase 대시보드에서 Edge Function의 스케줄링을 설정합니다.",
            "dependencies": [],
            "details": "1. Supabase 대시보드 접속\n2. Edge Functions 메뉴에서 scheduled-news-fetch 함수 배포\n3. 스케줄링 설정 추가: CRON 표현식 `0 * * * *` (매시간 실행)\n4. 타임존 설정: Asia/Seoul\n5. 인증 헤더 설정 (JWT 또는 API 키)\n6. 스케줄링 활성화\n7. 배포 확인",
            "status": "pending",
            "testStrategy": "1. 스케줄링 설정이 올바르게 저장되었는지 확인\n2. 수동으로 함수 실행하여 동작 확인\n3. 스케줄링된 시간에 자동 실행 확인\n4. 로그에서 실행 기록 확인"
          },
          {
            "id": 4,
            "title": "로깅 및 모니터링 시스템 구축",
            "description": "Edge Function 실행 로그를 저장하고 오류 발생 시 알림을 보내는 시스템을 구축합니다.",
            "dependencies": [],
            "details": "1. 로그 저장용 테이블 생성:\n```sql\nCREATE TABLE function_logs (\n  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),\n  function_name TEXT NOT NULL,\n  status TEXT NOT NULL,\n  execution_time FLOAT,\n  error_message TEXT,\n  created_at TIMESTAMPTZ DEFAULT NOW()\n);\n```\n2. Edge Function에 로깅 로직 추가\n3. 오류 발생 시 로그 저장 및 알림 발송 로직 구현\n4. 이메일 또는 Slack 웹훅을 통한 알림 설정\n5. 로그 보관 정책 설정 (30일 후 자동 삭제)",
            "status": "pending",
            "testStrategy": "1. 성공 케이스 로깅 확인\n2. 실패 케이스 로깅 확인\n3. 알림 발송 테스트\n4. 로그 조회 및 필터링 테스트\n5. 로그 보관 정책 테스트"
          },
          {
            "id": 5,
            "title": "스케줄링 시스템 테스트 및 최적화",
            "description": "구축된 스케줄링 시스템을 테스트하고 성능 및 안정성을 최적화합니다.",
            "dependencies": [],
            "details": "1. 전체 스케줄링 시스템 통합 테스트\n2. 다양한 시나리오에서의 동작 확인 (정상 실행, 오류 발생, 네트워크 지연 등)\n3. 성능 측정 및 병목 지점 식별\n4. 메모리 사용량 및 실행 시간 최적화\n5. 재시도 메커니즘 구현 (일시적 오류 발생 시)\n6. 백업 메커니즘 구현 (주 시스템 실패 시)\n7. 장기 실행 안정성 테스트",
            "status": "pending",
            "testStrategy": "1. 24시간 연속 실행 테스트\n2. 네트워크 오류 시뮬레이션\n3. 데이터베이스 연결 오류 시뮬레이션\n4. 대량 데이터 처리 시 성능 테스트\n5. 메모리 누수 테스트\n6. 재시도 로직 검증"
          }
        ]
      },
      {
        "id": 4,
        "title": "클러스터링 알고리즘 구현",
        "description": "수집된 뉴스 기사를 유사한 내용끼리 그룹화하는 클러스터링 알고리즘을 구현합니다.",
        "details": "1. docid 기반 클러스터링 로직 구현:\n```typescript\n// supabase/functions/clustering/index.ts\nimport { createClient } from '@supabase/supabase-js';\n\nconst supabaseUrl = Deno.env.get('SUPABASE_URL');\nconst supabaseKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY');\nconst supabase = createClient(supabaseUrl, supabaseKey);\n\nexport async function clusterArticles() {\n  // 클러스터링되지 않은 기사 가져오기\n  const { data: unclustered } = await supabase\n    .from('news_articles')\n    .select('*')\n    .is('cluster_id', null)\n    .order('published_at', { ascending: false });\n    \n  if (!unclustered || unclustered.length === 0) {\n    return;\n  }\n  \n  // 기존 클러스터 가져오기\n  const { data: existingClusters } = await supabase\n    .from('news_articles')\n    .select('cluster_id, title, keywords')\n    .not('cluster_id', 'is', null)\n    .order('published_at', { ascending: false });\n  \n  const clusters = {};\n  if (existingClusters) {\n    for (const article of existingClusters) {\n      if (!clusters[article.cluster_id]) {\n        clusters[article.cluster_id] = [];\n      }\n      clusters[article.cluster_id].push(article);\n    }\n  }\n  \n  // 각 미분류 기사에 대해 클러스터링 수행\n  for (const article of unclustered) {\n    let assigned = false;\n    \n    // 제목 유사도 기반 클러스터링\n    for (const [clusterId, clusterArticles] of Object.entries(clusters)) {\n      for (const clusterArticle of clusterArticles) {\n        if (calculateSimilarity(article.title, clusterArticle.title) > 0.7) {\n          // 유사도가 높으면 같은 클러스터에 할당\n          await supabase\n            .from('news_articles')\n            .update({ cluster_id: clusterId })\n            .eq('id', article.id);\n          assigned = true;\n          break;\n        }\n      }\n      if (assigned) break;\n    }\n    \n    // 새 클러스터 생성\n    if (!assigned) {\n      const newClusterId = crypto.randomUUID();\n      await supabase\n        .from('news_articles')\n        .update({ cluster_id: newClusterId })\n        .eq('id', article.id);\n    }\n  }\n}\n\nfunction calculateSimilarity(text1, text2) {\n  // 간단한 유사도 계산 알고리즘 (Jaccard 유사도 등)\n  const set1 = new Set(text1.toLowerCase().split(/\\s+/).filter(word => word.length > 2));\n  const set2 = new Set(text2.toLowerCase().split(/\\s+/).filter(word => word.length > 2));\n  \n  const intersection = new Set([...set1].filter(x => set2.has(x)));\n  const union = new Set([...set1, ...set2]);\n  \n  return intersection.size / union.size;\n}\n```\n\n2. 클러스터링 작업을 위한 스케줄링 설정\n3. 클러스터 대표 기사 선정 로직 구현 (조회수, 매체 신뢰도 등 고려)",
        "testStrategy": "1. 다양한 유사도 수준의 기사로 클러스터링 테스트\n2. 경계 케이스 테스트 (유사도가 경계값에 가까운 경우)\n3. 대량 데이터에서의 성능 테스트\n4. 클러스터 품질 평가 (수동 검증)\n5. 대표 기사 선정 로직 검증",
        "priority": "medium",
        "dependencies": [
          1,
          2,
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Next.js 프론트엔드 기본 구조 설정",
        "description": "Next.js 15.4.6, TypeScript, Tailwind CSS를 사용하여 프론트엔드 기본 구조를 설정합니다.",
        "details": "1. Next.js 프로젝트 생성:\n```bash\nnpx create-next-app@latest nasolo-news-hub --typescript --tailwind --eslint\ncd nasolo-news-hub\n```\n\n2. 필요한 패키지 설치:\n```bash\nnpm install @supabase/supabase-js date-fns\n```\n\n3. 기본 디렉토리 구조 설정:\n```\n/app\n  /api\n    /feed/route.ts\n    /cluster/[id]/route.ts\n    /search/route.ts\n  /components\n    /ui\n      Card.tsx\n      ClusterView.tsx\n      Header.tsx\n      Footer.tsx\n      SearchBar.tsx\n    /layout\n      MainLayout.tsx\n  /lib\n    supabase.ts\n    utils.ts\n    types.ts\n  /hooks\n    useNews.ts\n  page.tsx\n  layout.tsx\n  globals.css\n```\n\n4. Supabase 클라이언트 설정:\n```typescript\n// app/lib/supabase.ts\nimport { createClient } from '@supabase/supabase-js';\n\nexport const supabase = createClient(\n  process.env.NEXT_PUBLIC_SUPABASE_URL!,\n  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!\n);\n```\n\n5. 기본 타입 정의:\n```typescript\n// app/lib/types.ts\nexport interface NewsArticle {\n  id: string;\n  title: string;\n  article_url: string;\n  source: string;\n  published_at: string;\n  thumbnail_url?: string;\n  cluster_id?: string;\n  summary?: string;\n  keywords?: string[];\n  cast_members?: string[];\n}\n\nexport interface NewsCluster {\n  id: string;\n  main_article: NewsArticle;\n  related_articles: NewsArticle[];\n}\n```\n\n6. 환경 변수 설정 (.env.local)",
        "testStrategy": "1. Next.js 프로젝트 빌드 및 실행 테스트\n2. TypeScript 타입 검사 확인\n3. Tailwind CSS 스타일 적용 테스트\n4. Supabase 연결 테스트\n5. 기본 라우팅 테스트\n6. 개발 및 프로덕션 환경 설정 검증",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "API 엔드포인트 구현",
        "description": "뉴스 피드, 클러스터 상세보기, 검색 기능을 위한 API 엔드포인트를 구현합니다.",
        "details": "1. 피드 API 구현:\n```typescript\n// app/api/feed/route.ts\nimport { NextRequest, NextResponse } from 'next/server';\nimport { supabase } from '@/app/lib/supabase';\n\nexport async function GET(request: NextRequest) {\n  const searchParams = request.nextUrl.searchParams;\n  const cast = searchParams.get('cast');\n  const from = searchParams.get('from');\n  const to = searchParams.get('to');\n  const source = searchParams.get('source');\n  const sort = searchParams.get('sort') || 'date';\n  const page = parseInt(searchParams.get('page') || '1');\n  const size = parseInt(searchParams.get('size') || '20');\n  \n  let query = supabase\n    .from('news_articles')\n    .select('*')\n    .not('cluster_id', 'is', null);\n  \n  // 필터 적용\n  if (cast) {\n    query = query.contains('cast_members', [cast]);\n  }\n  \n  if (from) {\n    query = query.gte('published_at', from);\n  }\n  \n  if (to) {\n    query = query.lte('published_at', to);\n  }\n  \n  if (source) {\n    query = query.eq('source', source);\n  }\n  \n  // 정렬 및 페이지네이션\n  query = query.order('published_at', { ascending: sort === 'asc' });\n  query = query.range((page - 1) * size, page * size - 1);\n  \n  const { data, error, count } = await query;\n  \n  if (error) {\n    return NextResponse.json({ error: error.message }, { status: 500 });\n  }\n  \n  // 클러스터 그룹화\n  const clusters = {};\n  for (const article of data) {\n    if (!clusters[article.cluster_id]) {\n      clusters[article.cluster_id] = [];\n    }\n    clusters[article.cluster_id].push(article);\n  }\n  \n  // 클러스터 형식으로 변환\n  const result = Object.entries(clusters).map(([id, articles]) => {\n    const sortedArticles = articles.sort(\n      (a, b) => new Date(b.published_at).getTime() - new Date(a.published_at).getTime()\n    );\n    return {\n      id,\n      main_article: sortedArticles[0],\n      related_articles: sortedArticles.slice(1),\n      total_articles: sortedArticles.length\n    };\n  });\n  \n  return NextResponse.json({\n    clusters: result,\n    page,\n    size,\n    total: count\n  });\n}\n```\n\n2. 클러스터 상세 API 구현:\n```typescript\n// app/api/cluster/[id]/route.ts\nimport { NextRequest, NextResponse } from 'next/server';\nimport { supabase } from '@/app/lib/supabase';\n\nexport async function GET(request: NextRequest, { params }: { params: { id: string } }) {\n  const { id } = params;\n  \n  const { data, error } = await supabase\n    .from('news_articles')\n    .select('*')\n    .eq('cluster_id', id);\n  \n  if (error) {\n    return NextResponse.json({ error: error.message }, { status: 500 });\n  }\n  \n  if (!data || data.length === 0) {\n    return NextResponse.json({ error: 'Cluster not found' }, { status: 404 });\n  }\n  \n  // 대표 기사 선정 (최신 기사)\n  const sortedArticles = data.sort(\n    (a, b) => new Date(b.published_at).getTime() - new Date(a.published_at).getTime()\n  );\n  \n  return NextResponse.json({\n    id,\n    main_article: sortedArticles[0],\n    related_articles: sortedArticles.slice(1),\n    total_articles: sortedArticles.length\n  });\n}\n```\n\n3. 검색 API 구현:\n```typescript\n// app/api/search/route.ts\nimport { NextRequest, NextResponse } from 'next/server';\nimport { supabase } from '@/app/lib/supabase';\n\nexport async function GET(request: NextRequest) {\n  const searchParams = request.nextUrl.searchParams;\n  const q = searchParams.get('q');\n  const cast = searchParams.get('cast');\n  const from = searchParams.get('from');\n  const to = searchParams.get('to');\n  const page = parseInt(searchParams.get('page') || '1');\n  const size = parseInt(searchParams.get('size') || '20');\n  \n  if (!q && !cast) {\n    return NextResponse.json({ error: 'Search query or cast required' }, { status: 400 });\n  }\n  \n  let query = supabase.from('news_articles').select('*');\n  \n  // 검색어 적용\n  if (q) {\n    query = query.or(`title.ilike.%${q}%, summary.ilike.%${q}%`);\n  }\n  \n  // 필터 적용\n  if (cast) {\n    query = query.contains('cast_members', [cast]);\n  }\n  \n  if (from) {\n    query = query.gte('published_at', from);\n  }\n  \n  if (to) {\n    query = query.lte('published_at', to);\n  }\n  \n  // 정렬 및 페이지네이션\n  query = query.order('published_at', { ascending: false });\n  query = query.range((page - 1) * size, page * size - 1);\n  \n  const { data, error, count } = await query;\n  \n  if (error) {\n    return NextResponse.json({ error: error.message }, { status: 500 });\n  }\n  \n  return NextResponse.json({\n    articles: data,\n    page,\n    size,\n    total: count\n  });\n}\n```",
        "testStrategy": "1. 각 API 엔드포인트 기능 테스트\n2. 다양한 쿼리 파라미터 조합으로 테스트\n3. 페이지네이션 정확성 검증\n4. 에러 핸들링 테스트\n5. 응답 형식 및 데이터 구조 검증\n6. 성능 테스트 (대량 데이터 조회 시)",
        "priority": "high",
        "dependencies": [
          1,
          5
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "홈 피드 화면 구현",
        "description": "클러스터 카드 형태로 뉴스를 보여주는 홈 피드 화면을 구현합니다.",
        "details": "1. 홈 페이지 구현:\n```typescript\n// app/page.tsx\nimport { Suspense } from 'react';\nimport NewsFeed from './components/NewsFeed';\nimport SearchBar from './components/ui/SearchBar';\nimport Loading from './loading';\n\nexport default function Home() {\n  return (\n    <main className=\"container mx-auto px-4 py-8\">\n      <h1 className=\"text-3xl font-bold mb-6\">나는솔로 뉴스 허브</h1>\n      <SearchBar />\n      <Suspense fallback={<Loading />}>\n        <NewsFeed />\n      </Suspense>\n    </main>\n  );\n}\n```\n\n2. 뉴스 피드 컴포넌트 구현:\n```typescript\n// app/components/NewsFeed.tsx\n'use client';\n\nimport { useEffect, useState } from 'react';\nimport ClusterCard from './ui/ClusterCard';\nimport { NewsCluster } from '../lib/types';\n\nexport default function NewsFeed() {\n  const [clusters, setClusters] = useState<NewsCluster[]>([]);\n  const [loading, setLoading] = useState(true);\n  const [page, setPage] = useState(1);\n  const [hasMore, setHasMore] = useState(true);\n  \n  useEffect(() => {\n    fetchClusters();\n  }, [page]);\n  \n  async function fetchClusters() {\n    setLoading(true);\n    try {\n      const res = await fetch(`/api/feed?page=${page}&size=10`);\n      const data = await res.json();\n      \n      if (data.clusters.length === 0) {\n        setHasMore(false);\n      } else {\n        setClusters(prev => [...prev, ...data.clusters]);\n      }\n    } catch (error) {\n      console.error('Failed to fetch clusters:', error);\n    } finally {\n      setLoading(false);\n    }\n  }\n  \n  function loadMore() {\n    setPage(prev => prev + 1);\n  }\n  \n  return (\n    <div className=\"space-y-6\">\n      {clusters.map(cluster => (\n        <ClusterCard key={cluster.id} cluster={cluster} />\n      ))}\n      \n      {loading && <p className=\"text-center py-4\">로딩 중...</p>}\n      \n      {!loading && hasMore && (\n        <button\n          onClick={loadMore}\n          className=\"w-full py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 transition\"\n        >\n          더 보기\n        </button>\n      )}\n      \n      {!hasMore && <p className=\"text-center py-4\">모든 뉴스를 불러왔습니다.</p>}\n    </div>\n  );\n}\n```\n\n3. 클러스터 카드 컴포넌트 구현:\n```typescript\n// app/components/ui/ClusterCard.tsx\nimport Link from 'next/link';\nimport Image from 'next/image';\nimport { formatDistanceToNow } from 'date-fns';\nimport { ko } from 'date-fns/locale';\nimport { NewsCluster } from '@/app/lib/types';\n\ninterface ClusterCardProps {\n  cluster: NewsCluster;\n}\n\nexport default function ClusterCard({ cluster }: ClusterCardProps) {\n  const { id, main_article, related_articles, total_articles } = cluster;\n  \n  return (\n    <div className=\"border rounded-lg overflow-hidden shadow-md hover:shadow-lg transition\">\n      <Link href={`/cluster/${id}`}>\n        <div className=\"p-4\">\n          <div className=\"flex items-start gap-4\">\n            {main_article.thumbnail_url && (\n              <div className=\"flex-shrink-0\">\n                <Image\n                  src={main_article.thumbnail_url}\n                  alt={main_article.title}\n                  width={120}\n                  height={80}\n                  className=\"rounded-md object-cover\"\n                />\n              </div>\n            )}\n            \n            <div className=\"flex-grow\">\n              <h2 className=\"text-xl font-semibold mb-2\">{main_article.title}</h2>\n              <p className=\"text-gray-600 line-clamp-2 mb-2\">{main_article.summary}</p>\n              \n              <div className=\"flex justify-between items-center text-sm text-gray-500\">\n                <span>{main_article.source}</span>\n                <span>\n                  {formatDistanceToNow(new Date(main_article.published_at), {\n                    addSuffix: true,\n                    locale: ko\n                  })}\n                </span>\n              </div>\n            </div>\n          </div>\n          \n          {related_articles.length > 0 && (\n            <div className=\"mt-4 pt-3 border-t\">\n              <p className=\"text-sm font-medium mb-2\">관련 기사 {total_articles - 1}개</p>\n              <ul className=\"space-y-1\">\n                {related_articles.slice(0, 3).map(article => (\n                  <li key={article.id} className=\"text-sm text-gray-700 truncate\">\n                    • {article.title}\n                  </li>\n                ))}\n                {related_articles.length > 3 && (\n                  <li className=\"text-sm text-blue-500\">+ 더 보기</li>\n                )}\n              </ul>\n            </div>\n          )}\n        </div>\n      </Link>\n    </div>\n  );\n}\n```\n\n4. 검색바 컴포넌트 구현:\n```typescript\n// app/components/ui/SearchBar.tsx\n'use client';\n\nimport { useState, FormEvent } from 'react';\nimport { useRouter } from 'next/navigation';\n\nexport default function SearchBar() {\n  const [query, setQuery] = useState('');\n  const router = useRouter();\n  \n  function handleSubmit(e: FormEvent) {\n    e.preventDefault();\n    if (query.trim()) {\n      router.push(`/search?q=${encodeURIComponent(query)}`);\n    }\n  }\n  \n  return (\n    <form onSubmit={handleSubmit} className=\"mb-6\">\n      <div className=\"flex\">\n        <input\n          type=\"text\"\n          value={query}\n          onChange={(e) => setQuery(e.target.value)}\n          placeholder=\"출연자 이름, 키워드로 검색\"\n          className=\"flex-grow px-4 py-2 border rounded-l-md focus:outline-none focus:ring-2 focus:ring-blue-500\"\n        />\n        <button\n          type=\"submit\"\n          className=\"bg-blue-500 text-white px-4 py-2 rounded-r-md hover:bg-blue-600 transition\"\n        >\n          검색\n        </button>\n      </div>\n    </form>\n  );\n}\n```",
        "testStrategy": "1. 컴포넌트 렌더링 테스트\n2. 반응형 디자인 검증 (모바일, 태블릿, 데스크톱)\n3. 데이터 로딩 및 표시 테스트\n4. 무한 스크롤/페이지네이션 기능 테스트\n5. 검색 기능 테스트\n6. 에러 상태 및 로딩 상태 UI 테스트\n7. 성능 최적화 검증 (이미지 최적화, 코드 스플리팅 등)",
        "priority": "medium",
        "dependencies": [
          5,
          6
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "성능 최적화 및 배포",
        "description": "애플리케이션의 성능을 최적화하고 프로덕션 환경에 배포합니다.",
        "details": "1. 이미지 최적화:\n   - Next.js Image 컴포넌트 활용\n   - 이미지 캐싱 및 CDN 설정\n\n2. API 응답 캐싱:\n```typescript\n// app/api/feed/route.ts 수정\nimport { NextRequest, NextResponse } from 'next/server';\n\nexport const revalidate = 3600; // 1시간마다 캐시 갱신\n\nexport async function GET(request: NextRequest) {\n  // 기존 코드...\n}\n```\n\n3. 서버 컴포넌트 활용:\n```typescript\n// app/components/ServerNewsFeed.tsx\nimport { supabase } from '../lib/supabase';\nimport ClusterCard from './ui/ClusterCard';\n\nexport default async function ServerNewsFeed() {\n  const { data } = await supabase\n    .from('news_articles')\n    .select('*')\n    .not('cluster_id', 'is', null)\n    .order('published_at', { ascending: false })\n    .limit(20);\n  \n  // 클러스터링 로직...\n  \n  return (\n    <div className=\"space-y-6\">\n      {clusters.map(cluster => (\n        <ClusterCard key={cluster.id} cluster={cluster} />\n      ))}\n    </div>\n  );\n}\n```\n\n4. 코드 스플리팅 및 지연 로딩:\n```typescript\nimport dynamic from 'next/dynamic';\n\nconst DynamicSearchResults = dynamic(\n  () => import('./components/SearchResults'),\n  { loading: () => <p>로딩 중...</p> }\n);\n```\n\n5. 배포 설정:\n   - Vercel 또는 다른 호스팅 서비스 설정\n   - 환경 변수 구성\n   - CI/CD 파이프라인 설정\n\n6. 모니터링 및 분석:\n   - 성능 모니터링 도구 설정 (Vercel Analytics 등)\n   - 오류 추적 시스템 구축\n\n7. SEO 최적화:\n```typescript\n// app/layout.tsx\nexport const metadata = {\n  title: '나는솔로 뉴스 허브',\n  description: '나는 SOLO 및 출연자 관련 언론 기사와 이슈를 한 곳에서 빠르게 볼 수 있는 뉴스 플랫폼',\n  openGraph: {\n    title: '나는솔로 뉴스 허브',\n    description: '나는 SOLO 관련 뉴스를 한 곳에서',\n    images: ['/og-image.jpg'],\n  },\n};\n```",
        "testStrategy": "1. 성능 측정 (Lighthouse, Web Vitals)\n2. 로딩 시간 및 TTI(Time to Interactive) 측정\n3. 모바일 성능 테스트\n4. 캐싱 전략 검증\n5. SEO 점수 확인\n6. 프로덕션 환경에서의 오류 모니터링\n7. 사용자 경험 테스트 (실제 사용자 피드백)\n8. 보안 취약점 스캔",
        "priority": "medium",
        "dependencies": [
          5,
          6,
          7
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-08-12T14:17:53.346Z",
      "updated": "2025-08-12T16:28:08.140Z",
      "description": "Tasks for master context"
    }
  }
}